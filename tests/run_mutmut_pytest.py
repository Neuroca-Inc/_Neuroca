
"""Mutation-test runner that normalises imports inside ``mutmut`` clones.

Mutmut clones the repository into a temporary ``mutants/`` directory before executing
pytest. Because the project uses a ``src/`` layout, the cloned tests need that directory
prepended to ``sys.path`` or they fail to import project modules. This helper performs
three tasks before delegating to pytest:

1. Determine the relevant ``src`` directories within both the real repository and the
   clone produced by mutmut.
2. Ensure those directories are present on ``sys.path`` and reflected in the
   ``PYTHONPATH`` environment variable for subprocess compatibility.
3. Hydrate the clone with any source modules that mutmut omitted so that imports remain
   stable even when only part of the tree is copied.

The runner then invokes the health-focused unit tests used for mutation analysis and
propagates pytest's exit status back to mutmut.
"""
from __future__ import annotations

import os
import sys
from pathlib import Path
from typing import Iterable

import pytest


def _iter_candidate_paths(root: Path) -> Iterable[Path]:
    """Yield project ``src`` directories that should be importable.

    Args:
        root: Root directory passed to the function. When executed inside mutmut the
            ``tests`` folder lives under ``mutants/<hash>/tests`` so ``root`` resolves
            to that location.

    Yields:
        Paths that should be added to ``sys.path`` in order of priority.
    """

    yield root / "src"
    yield root.parent / "src"


def _ensure_sys_path(candidate_paths: Iterable[Path]) -> list[str]:
    """Prepend valid candidate paths to ``sys.path``.

    Args:
        candidate_paths: Potential source directories discovered via
            :func:`_iter_candidate_paths`.

    Returns:
        A list of stringified paths that were inserted so callers can update
        ``PYTHONPATH`` for subprocess-aware tooling.
    """

    inserted: list[str] = []
    for path in candidate_paths:
        resolved = path.resolve()
        if not resolved.exists():
            continue
        resolved_str = str(resolved)
        if resolved_str not in sys.path:
            sys.path.insert(0, resolved_str)
            inserted.append(resolved_str)
    return inserted


def _copy_tree(source: Path, target: Path) -> None:
    """Copy ``source`` into ``target``, merging directories when necessary.

    Args:
        source: File or directory that should exist in the mutmut clone.
        target: Destination path inside the clone.

    Side Effects:
        Creates directories and writes files so that the clone mirrors the original
        project structure required by the tests.
    """

    if source.is_file():
        if target.exists():
            return
        target.write_bytes(source.read_bytes())
        return

    if source.is_dir():
        target.mkdir(parents=True, exist_ok=True)
        for child in source.iterdir():
            _copy_tree(child, target / child.name)


def _hydrate_support_modules(mutants_root: Path) -> None:
    """Copy missing support modules into the mutmut clone.

    Mutmut sometimes creates shallow copies of the ``src`` tree that omit unmodified
    packages. This helper ensures the ``neuroca`` package is fully present so imports
    succeed regardless of which module mutmut is currently mutating.

    Args:
        mutants_root: Directory holding the cloned repository generated by mutmut.
    """

    mutated_src = mutants_root / "src"
    original_src = mutants_root.parent / "src"

    mutated_pkg = mutated_src / "neuroca"
    original_pkg = original_src / "neuroca"

    if not mutated_pkg.exists() or not original_pkg.exists():
        return

    for source in original_pkg.iterdir():
        _copy_tree(source, mutated_pkg / source.name)


def main() -> int:
    """Configure import paths and delegate to pytest.

    Returns:
        Pytest's exit code so mutmut can make decisions about mutant status.
    """

    project_root = Path(__file__).resolve().parent.parent
    _hydrate_support_modules(project_root)
    added_paths = _ensure_sys_path(_iter_candidate_paths(project_root))

    if added_paths:
        existing = os.environ.get("PYTHONPATH")
        new_segments = os.pathsep.join(added_paths)
        os.environ["PYTHONPATH"] = (
            f"{new_segments}{os.pathsep}{existing}" if existing else new_segments
        )

    return pytest.main(["-q", "tests/unit/health"])


if __name__ == "__main__":
    raise SystemExit(main())
