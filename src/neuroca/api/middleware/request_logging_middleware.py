"""Request logging middleware for the NeuroCognitive Architecture API.

The middleware enriches HTTP requests and responses with correlation IDs,
structured logging, and payload sanitization so operational teams can trace
interactions without leaking sensitive information.
"""

from __future__ import annotations

import json
import logging
import time
from typing import Any, Optional

from fastapi import FastAPI, Request, Response
from starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint
from starlette.types import ASGIApp

from neuroca.monitoring.logging import clear_context, set_request_logging_context

from .logging_helpers import (
    DEFAULT_EXCLUDE_PATHS,
    format_placeholder,
    get_request_logger,
    sanitize_body,
    sanitize_headers,
    set_correlation_id,
)

logger = logging.getLogger("neuroca.api.middleware.logging")


class RequestLoggingMiddleware(BaseHTTPMiddleware):
    """Middleware that logs incoming requests and outgoing responses."""

    def __init__(
        self,
        app: ASGIApp,
        exclude_paths: Optional[set[str]] = None,
        log_request_body: bool = True,
        log_response_body: bool = True,
        log_level: int = logging.INFO,
        correlation_id_header: str = "X-Correlation-ID",
    ) -> None:
        """Initialize the middleware with optional overrides.

        Args:
            app: Wrapped ASGI application.
            exclude_paths: Paths that should bypass logging.
            log_request_body: Flag indicating whether to log request payloads.
            log_response_body: Flag indicating whether to log response payloads.
            log_level: Base logging level for successful responses.
            correlation_id_header: Header used for propagating correlation IDs.
        """

        super().__init__(app)
        self.exclude_paths = exclude_paths or DEFAULT_EXCLUDE_PATHS
        self.log_request_body = log_request_body
        self.log_response_body = log_response_body
        self.log_level = log_level
        self.correlation_id_header = correlation_id_header

    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:
        """Process the request while recording lifecycle events.

        Args:
            request: Incoming HTTP request.
            call_next: Next handler in the ASGI middleware chain.

        Returns:
            Response: Response generated by downstream handlers.
        """

        clear_context()

        if self._should_skip_path(request.url.path):
            return await call_next(request)

        correlation_id = self._ensure_correlation_id(request.headers.get(self.correlation_id_header))
        set_request_logging_context(request_id=correlation_id)
        request_logger = get_request_logger()
        start_time = time.time()

        await self._log_request(request, request_logger)

        try:
            response = await call_next(request)
        except Exception as exc:  # pragma: no cover - defensive logging path
            process_time = time.time() - start_time
            self._log_exception(exc, process_time, request_logger)
            clear_context()
            raise

        process_time = time.time() - start_time
        self._finalize_response(response, process_time, correlation_id, request_logger)
        clear_context()
        return response

    def _should_skip_path(self, path: str) -> bool:
        """Return whether the supplied path is configured to bypass logging.

        Args:
            path: The HTTP path extracted from the incoming request.

        Returns:
            bool: ``True`` when the request should not be logged.
        """

        return path in self.exclude_paths

    def _ensure_correlation_id(self, provided_id: Optional[str]) -> str:
        """Store and return the correlation identifier for the current request.

        Args:
            provided_id: Optional identifier supplied by the client.

        Returns:
            str: The identifier that will be propagated with the response.
        """

        return set_correlation_id(provided_id)

    async def _log_request(self, request: Request, request_logger: logging.LoggerAdapter) -> None:
        """Log incoming request metadata and payload.

        Args:
            request: The current HTTP request.
            request_logger: Logger adapter enriched with the correlation ID.
        """

        request_info = await self._build_request_info(request, request_logger)
        request_logger.log(
            self.log_level,
            "Incoming request: %s %s",
            request.method,
            request.url.path,
            extra={"request": request_info},
        )

    async def _build_request_info(
        self, request: Request, request_logger: logging.LoggerAdapter
    ) -> dict[str, Any]:
        """Collect metadata used for logging the incoming request.

        Args:
            request: The current HTTP request.
            request_logger: Logger adapter used for warning messages.

        Returns:
            dict[str, Any]: Structured metadata describing the request.
        """

        request_info: dict[str, Any] = {
            "method": request.method,
            "url": str(request.url),
            "client_host": request.client.host if request.client else None,
            "headers": sanitize_headers(dict(request.headers)),
            "query_params": dict(request.query_params),
            "path_params": request.path_params,
        }

        if self.log_request_body:
            request_info["body"] = await self._capture_request_body(request, request_logger)

        return request_info

    async def _capture_request_body(
        self, request: Request, request_logger: logging.LoggerAdapter
    ) -> str | dict[str, Any] | list[Any] | None:
        """Safely capture and sanitize the request payload.

        Args:
            request: The current HTTP request.
            request_logger: Logger adapter used to report capture failures.

        Returns:
            Union[str, dict[str, Any], list[Any], None]: Sanitized payload ready
            for logging. ``None`` is returned when the request has no body.
        """

        try:
            body_bytes = await request.body()
            request.scope["_body"] = body_bytes
            try:
                body = json.loads(body_bytes.decode("utf-8"))
            except (json.JSONDecodeError, UnicodeDecodeError):
                content_type = request.headers.get("content-type")
                return format_placeholder("binary or non-JSON data", content_type)
            return sanitize_body(body)
        except Exception as exc:  # pragma: no cover - defensive logging path
            request_logger.warning("Failed to capture request body: %s", exc)
            return "<error reading body>"

    def _log_exception(
        self, exc: Exception, process_time: float, request_logger: logging.LoggerAdapter
    ) -> None:
        """Emit structured logs for exceptions raised by downstream handlers.

        Args:
            exc: The exception raised by downstream handlers.
            process_time: Time spent handling the request before the failure.
            request_logger: Logger adapter enriched with request metadata.
        """

        request_logger.exception(
            "Request failed after %.4fs: %s",
            process_time,
            exc,
            extra={"exception": str(exc), "process_time": process_time},
        )

    def _finalize_response(
        self,
        response: Response,
        process_time: float,
        correlation_id: str,
        response_logger: logging.LoggerAdapter,
    ) -> None:
        """Attach correlation information and log the outgoing response.

        Args:
            response: HTTP response generated by downstream handlers.
            process_time: Duration spent processing the request.
            correlation_id: Correlation identifier associated with the request.
            response_logger: Logger adapter enriched with correlation metadata.
        """

        response_info = self._build_response_info(response, process_time)
        log_level = self._determine_log_level(response.status_code)
        response_logger.log(
            log_level,
            "Response: %s (took %.4fs)",
            response.status_code,
            process_time,
            extra={"response": response_info},
        )
        response.headers[self.correlation_id_header] = correlation_id

    def _build_response_info(self, response: Response, process_time: float) -> dict[str, Any]:
        """Collect metadata used when logging a response.

        Args:
            response: HTTP response generated by downstream handlers.
            process_time: Duration spent processing the request.

        Returns:
            dict[str, Any]: Structured metadata describing the response.
        """

        response_info: dict[str, Any] = {
            "status_code": response.status_code,
            "headers": sanitize_headers(dict(response.headers)),
            "process_time": f"{process_time:.4f}s",
        }

        if self.log_response_body:
            response_info["body"] = self._capture_response_body(response)

        return response_info

    def _capture_response_body(self, response: Response) -> str | dict[str, Any] | list[Any] | None:
        """Sanitize the response payload for safe logging.

        Args:
            response: HTTP response generated by downstream handlers.

        Returns:
            Union[str, dict[str, Any], list[Any], None]: Sanitized payload ready
            for logging. ``None`` is returned when the response does not include
            a body that should be logged.
        """

        content_type = response.headers.get("content-type", "")
        if "application/json" in content_type:
            try:
                body = json.loads(response.body.decode("utf-8"))
            except (json.JSONDecodeError, UnicodeDecodeError, AttributeError):
                return "<error decoding JSON body>"
            return sanitize_body(body)

        if "text/" in content_type:
            try:
                return response.body.decode("utf-8")
            except (UnicodeDecodeError, AttributeError):
                return "<error decoding text body>"

        return format_placeholder("binary data", content_type)

    def _determine_log_level(self, status_code: int) -> int:
        """Return the logging level appropriate for the status code.

        Args:
            status_code: HTTP status code returned by the endpoint.

        Returns:
            int: Logging level derived from the response classification.
        """

        if status_code >= 500:
            return logging.ERROR
        if status_code >= 400:
            return logging.WARNING
        return self.log_level


def setup_request_logging(
    app: FastAPI,
    exclude_paths: Optional[set[str]] = None,
    log_request_body: bool = True,
    log_response_body: bool = True,
    log_level: int = logging.INFO,
    correlation_id_header: str = "X-Correlation-ID",
) -> None:
    """Install the request logging middleware on a FastAPI application.

    Args:
        app: Target FastAPI application.
        exclude_paths: Paths that should not be logged.
        log_request_body: Whether to log request payloads.
        log_response_body: Whether to log response payloads.
        log_level: Base log level for successful requests.
        correlation_id_header: Header name to propagate correlation IDs.
    """

    app.add_middleware(
        RequestLoggingMiddleware,
        exclude_paths=exclude_paths,
        log_request_body=log_request_body,
        log_response_body=log_response_body,
        log_level=log_level,
        correlation_id_header=correlation_id_header,
    )
    logger.info("Request logging middleware configured")


__all__ = ["RequestLoggingMiddleware", "setup_request_logging"]
